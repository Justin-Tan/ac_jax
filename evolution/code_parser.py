"""Class for evaluating programs proposed by the Sampler."""

from copy import copy
import jax
import jax.numpy as jnp
import ast

from typing import Sequence, Any

from evolution import code_types, code_utils

class _FunctionLineVisitor(ast.NodeVisitor):
    """Visitor that finds the last line number of a function with a given name."""
    
    def __init__(self, target_function_name: str) -> None:
        self._target_function_name: str = target_function_name
        self._function_end_line: int | None = None

    def visit_FunctionDef(self, node: Any) -> None:  # pylint: disable=invalid-name
        """Collects the end line number of the target function."""
        if node.name == self._target_function_name:
            self._function_end_line = node.end_lineno
        self.generic_visit(node)

    @property
    def function_end_line(self) -> int:
        """Line number of the final line of function `target_function_name`."""
        assert self._function_end_line is not None  # Check internal correctness.
        return self._function_end_line

def _trim_function_body(generated_code: str) -> str:
    """Extracts body of LLM-generated function, trimming postscript."""
    if not generated_code: return ''
    code = f'def dummy_header():\n{generated_code}'
    tree = None
    # We keep trying and deleting code from the end until the parser succeeds.
    while tree is None:
        try:
            tree = ast.parse(code)
        except SyntaxError as e:
            code = '\n'.join(code.splitlines()[:e.lineno - 1])
    if not code:
        # Nothing could be saved from `generated_code`
        return ''
    
    # get body only
    visitor = _FunctionLineVisitor('dummy_header')
    visitor.visit(tree)
    body_lines = code.splitlines()[1:visitor.function_end_line]
    return '\n'.join(body_lines) + '\n\n'

def _sample_to_program(generated_code: str, version_generated: int | None, template: code_types.Program, 
                      function_to_evolve: str) -> tuple[code_utils.Function, str]:
    """Returns parsed function and python executable as string"""

    # preflight validation
    if not _validate_sample(generated_code):
        raise ValueError(f'Warning: code generated contains questionable commands!\n{generated_code}')

    body = _trim_function_body(generated_code)

    if version_generated is not None:  # rename recursive calls
        body = code_utils.rename_function_calls(body,
            f'{function_to_evolve}_v{version_generated}',
            function_to_evolve)

    # overwrite template body with body from LLM output
    program = copy.deepcopy(template)
    evolved_function = program.get_function(function_to_evolve)
    evolved_function.body = body
    return evolved_function, str(program)


class SecurityViolation(Exception):
    """Raised when generated code contains security violations."""
    pass

def _validate_sample(sample: str) -> bool:
    # minimal validation, non-comprehensive
    wrapped_code = f"def safety_dummy_header():\n{sample}"
    try:
        tree = ast.parse(wrapped_code)
    except SyntaxError:
        return False
    
    banned_calls = {'eval', 'exec', 'compile', 'open', 'input', 
        '__import__', 'globals', 'locals', 'super', 'getattr', 'setattr'}
    banned_modules = {'os', 'sys', 'subprocess', 'shutil', 'socket', 'pickle'}

    class SafeASTVisitor(ast.NodeVisitor):
        def visit_Import(self, node) -> None:
            for alias in node.names:
                base_module = alias.name.split('.')[0]
                if base_module in banned_modules:
                    raise SecurityViolation
                
        def visit_ImportFrom(self, node) -> None:
            if node.module and node.module.split('.')[0] in banned_modules:
                raise SecurityViolation
        
        def visit_Call(self, node) -> None:
            if isinstance(node.func, ast.Name):
                if node.func.id in banned_calls:
                    raise SecurityViolation
            elif isinstance(node.func, ast.Attribute):
                if node.func.attr in {'system', 'popen', 'open', 'spawn'}:
                    raise SecurityViolation
            self.generic_visit(node)

        def visit_Attribute(self, node) -> None:
            if node.attr in {'__globals__', '__code__', '__subclasses__'}:
                raise SecurityViolation
            self.generic_visit(node)

    visitor = SafeASTVisitor()
    try:
        visitor.visit(tree)
        return True
    except SecurityViolation:
        return False
        

class Evaluator:
    """
    Parses raw string generated by LLM and scores resulting program via execution
    on test suite in sandbox.
    """

    def __init__(
        self, database, template: code_types.Program, function_to_evolve: str, function_to_run: str,
        inputs: Sequence[Any], timeout_seconds: int = 60):
        """        
        template: base program scaffold (imports, helper fundefs, target docstring)
        function_to_evolve: name of function to be evolved by LLM
        function_to_run: name of function to be executed for scoring, wrapper around function_to_evolve
        inputs: test cases used for evaluation and scoring.
        """
        self._database = database
        self._template = template
        self._function_to_evolve = function_to_evolve
        self._function_to_run = function_to_run
        self._inputs = inputs
        self._timeout_seconds = timeout_seconds
        self._sandbox = Sandbox()

    def analyse(self, sample: str, island_id: int | None, version_generated: int | None) -> None:
        """Compiles the sample into a program and executes it on test inputs."""

        new_function, program = _sample_to_program(
            sample, version_generated, self._template, self._function_to_evolve)

        scores_per_test = {}

        if scores_per_test:
            self._database.register_program(new_function, island_id, scores_per_test)