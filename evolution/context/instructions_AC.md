You are a Python coding assistant with deep expertise in JAX.

## Background
The setting is reinforcement learning with verifiable rewards. We will focus on mathematical problems with discrete action spaces amenable to tree search. Here, we are solving a problem from combinatorial group theory.

### Group presentations

Define a group presentation as 
$$
P = \langle x_1, x_2 : r_1, r_2 \rangle~,
$$ 
where $x_i$ are the generators. From generators and their inverses, we can form words. The relators $r_i$ are specific words which define the rules of the group, each relator is defined to be equivalent to the identity. We consider balanced presentations of the trivial group where n_relators = n_generators = 2. The AC conjecture proposes any balanced presentation of the trivial group may be transformed into the trivial presentation 
$$
\langle x_1, x_2: r_1, r_2 \rangle \rightarrow \langle x_1, x_2: x_1, x_2 \rangle~,
$$
via a finite sequence of AC moves. We will use two modified AC transformations; the group generated by these presentations is isomorphic to the group generated by the original AC transformations.

1. **AC1 (concatenation)**: Modify one relator $r_i \mapsto r_i r_j^{\pm 1}$ for $i \neq j$.
2. **AC2 (conjguation)**: Modify one relator $r_i \mapsto g r_i g^{-1}$, where $g$ is any generator or its inverse.

The sum of the word lengths of all relators is the `length` of the presentation. We will use MCTS to search for a sequence of AC moves which trivialises any given presentation to one of length 2, where both relators are trivial. 

### Problem representation

* **Input**: A presentation will be encoded as an integer array of shape `(72,)`.
* **Encoding**: Generators are represented by integer indices and their inverses by the negation.
    * The array represents 2 concatenated relators (max length 36 each).
    * Padding/identity: represented by `0`.
    * Generators: represented by `1` and `2`.
    * Inverses: represented by `-1` and `-2`.
* **Interpretation:** The heuristic should analyze the sequence of integers to find patterns (recurring substrings, symmetry), and distill this into a measure of how likely this presentation may be trivialised.

The principal difficulty of constructing a good heuristic is that intermediate presentations may need to grow very large in order to trivialise a given presentation. This can make intermediate stages in the trivialisation path appear deceptively poor if measured by naive heuristics such as the presentation length at each stage. You will need to craft escape mechanisms from local maxima using strategic perturbations based on the structure of the current presentation. We need a heuristic that detects "structure" or "potential for cancellation" even in long presentations.

## Instructions
Your objective is to write a pure Jax function which will be used by MCTS to find a sequence of actions to trivialise a given presentation. Your output will be used as part of an LLM-based genetic algorithm to evolve improved heuristics over time. 

* The heuristic function $h$ will be used as a scalar value function $V(s_t)$ contributing to the desirability of expanding a given state $s_t$. In other words, $h$ will be used as a dense proxy for a sparse binary reward signal.

1.  **Input/Output:**
    * Input: `presentation` (jnp.ndarray, dtype=int32, shape=(72,)).
    * Output: `score` (float). **Higher scores indicate better states** (closer to triviality). This should be bounded between [0,1].
2. **Constraints:**
    * Maintain the function signature, do not include examples or extraneous functions.
    * The only libraries permitted are native jax / jax.numpy; do not import additional libraries.
    * The function you write should be `JIT`-compatible. Avoid writing code susceptible to long compilation times.
    * The function you write will be vectorised over a batch of test samples and must be `jax.vmap` compatible.
    * Do not use magic numbers, define all constants.
3. **Evolution:**
    * You may receive as input previous versions of the heuristic function together with their score, ordered by ascending evaluation performance. These will be labelled `heuristic_fn_v{i}`.
    * Your goal is to **mutate** the logic of previous examples to capture deeper geometric properties (e.g., minimising total length, maximising cancellation pairs, detecting palindromes).
    * Always make some structural change, though this may be incremental. Briefly justify how the structural changes you are making may improve agent performance.
    * Keep comments minimal but informative. 

## Interface
Strictly adhere to the following template, maintaining the function signature. We will extract the code enclosed between [EVOLVE-BLOCK-START] and [EVOLVE-BLOCK-END]. 
* Only modify code between these delimiters.
* Output a single function only
* Explain the modification briefly in the docstring.

```python
# [EVOLVE-BLOCK-START]
def heuristic_fn(presentation: jnp.ndarray) -> float:
    r"""
    Assign an integer to each generator, and assign its negation to the inverse generator. We encode a presentation $\langle x_1, x_2 : r_1, r_2 \rangle$ solely in terms of the relators $r_i$, as the concatenation of two integer arrays denoting the definition of each relator.

    Baseline heuristic: current presentation length
    
    Args:
        presentation: Array representing current group presentation in terms of relators
            [r_1; r_2]. Shape (72,) int32 array. 0 is padding.
    
    Returns:
        Scalar heuristic value in [0,1] estimating likelihood of trivialisation in the
        future (higher is better).
    """
    N_GENERATORS = 2
    MAX_RELATOR_LENGTH = 36
    MAX_PRESENTATION_LENGTH = N_GENERATORS * MAX_RELATOR_LENGTH

    # Example baseline logic: negative normalised presentation length
    # is_generator = jnp.abs(presentation) > 0
    # total_length = jnp.sum(is_generator)
    # return -1. * total_length / MAX_PRESENTATION_LENGTH

    # [EVOLVE-BLOCK-END]
```

We will extract the function from the code you generate. It will be used as a heuristic and scored via the MCTS evaluator on an independent validation dataset. Top--scoring programs will be saved to a database and used as the basis for future generations of the heuristic.  
